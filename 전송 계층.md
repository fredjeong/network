# 4. 전송 계층

## 4.1 전송 계층 개요: IP의 한계와 포트

### 신뢰할 수 없는 통신과 비연결형 통신

- IP의 한계
    - 신뢰할 수 없는 프로토콜(unreliable protocol)
        - 최선형 전달(best effort delivery)
            - 통신 과정에서 패킷의 데이터가 손상되거나 중복된 패킷이 전송되었더라도 이를 확인하지 않고, 재전송도 하지 않으며, 순서대로 패킷이 도착할 것이라는 보장도 하지 않음
    - 비연결형 프로토콜(connectionless protocol)
        - 송수신 호스트 간에 사전 연결 수립 작업을 거치지 않는 특징을 의미
- IP를 통한 패킷의 전달은 신뢰성이 없는 통신이자 연결을 수립하는 과정이 없는 통신

### IP의 한계를 보완하는 전송 계층

- TCP
    - 연결형 통신 가능
    - 신뢰성 있는 통신 가능
- UDP
    - 높은 성능을 위해 신뢰할 수 없는 통신, 비연결형 통신 가능  

### 응용 계층과의 다리, 포트

#### 포트의 정의

- 패킷은 호스트에 도착한 뒤에 실행 중인 특정 애플리케이션 프로세스까지 전달되어야 함
- 패킷이 실행 중인 특정 애플리케이션까지 전달되려면 패킷에 특정 애플리케이션을 식별할 수 있는 정보인 포트(port)가 포함되어야 함

#### 포트의 분류

- 전송 계층에서는 포트 번호를 통해 애플리케이션을 식별
- 포트 번호는 16비트로 표현하므로 $2^{16}=65536$개의 포트 번호 할당 가능
- 종류
    - 잘 알려진 포트(well known port) 또는 시스템 포트
        - 범용적으로 사용되는 애플리케이션 프로토콜이 일반적으로 사용하는 포트 번호
    - 등록된 포트(registered port)
        - 잘 알려진 포트에 비해서는 덜 범용적이지만 흔히 사용되는 애플리케이션 프로토콜에 할당되는 번호
    - 동적 포트(dynamic port) 또는 사설 포트(private port) 또는 임시 포트(ephemeral port)
        - 특별히 관리되지 않는 포트이므로 자유롭게 사용할 수 있음
- 서버로서 동작하는 프로그램은 일반적으로 잘 알려진 포트와 등록된 포트로 동작
- 웹 브라우저와 같이 클라이언트로서 동작하는 프로그램은 동적 포트로 동작
- IP 주소와 포트 번호에 대한 정보가 함께 주어지면 특정 호스트에서 실행 중인 특정 애플리케이션 프로세스를 식별할 수 있음

### 포트 기반 NAT

#### NAT 변환 테이블

- IP 변환 기술인 NAT(Network Address Translation)를 위해 사용
- 네트워크 내부의 주소와 네트워크 외부 주소의 쌍을 기록
- 일대일 대응의 경우 공인 IP 주소가 지나치게 많이 필요하므로 NAT 기술은 포트를 이용하여 다수의 사설 IP 주소를 그보다 적은 수의 공인 IP 주소로 변환

#### NAPT (Network Address Port Translation) 또는 APT(Address Port Translation)

- 포트를 활용해 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 하는 NAT의 일종

## 4.2 TCP와 UDP

- 전송 계층 프로토콜 분류
    - TCP (Transmission Control Protocol)
        - 신뢰할 수 있는 통신을 위한 연결형 프로토콜
    - UDP (User Datagram Protocol)
        - 빠른 통신이 가능한 비연결형 프로토콜

### TCP 통신 단위와 세그먼트 구조

- TCP는 통신(데이터 송수신)하기 전에 연결을 수립하고 통신이 끝나면 연결 종료
- 데이터 송수신 과정에서 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등 기능 제공
- TCP 헤더 필드
    - 송신지 포트(source port)와 수신지 포트(destination port)
        - 송신지 또는 수신지 애플리케이션을 식별하는 포트 번호가 명시
    - 순서 번호(sequence number)
        - 송수신되는 세그먼트의 올바른 순서를 보장하기 위해 세그먼트 데이터의 첫 바이트에 부여되는 번호
    - 확인 응답 번호(acknowledgement number)
        - 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하기를 기대하는 순서 번호 명시
    - 제어 비트(control bits) 또는 플래그 비트
        - 현재 세그먼트에 대한 부가 정보
    - 윈도우(Window)
        - 한 번에 수신하고자 하는 데이터의 양인 윈도우의 크기

#### 제어 비트

- 8비트로 구성
- 대표적인 종류
    - ACK
        - 세그먼트의 승인을 나타내기 위한 비트
    - SYN
        - 연결을 수립하기 위한 비트
    - FIN
        - 연결을 종료하기 위한 비트

#### 순서 번호와 확인 응답 번호

- TCP의 신뢰성을 보장하기 위해 사용
- 순서 번호
    - 세그먼트의 올바른 송수신 순서를 보장
- 확인 응답 번호
    - 수신자가 다음으로 받기를 기대하는 순서 번호
    - 확인 응답 번호 값을 보내기 위해서는 제어 비트에서 승인을 나타내는 비트인 ACK 플래그를 1로 설정해야 함

### TCP 연결 수립과 종료

#### 연결 수립: 쓰리 웨이 핸드셰이크(three-way handshake)

- 호스트 A와 B가 쓰리 웨이 핸드셰이크를 할 때, 세 단계를 거친 뒤 송수신이 시작됨
    1. A to B
        - SYN 세그먼트
        - 주요 정보
            - 호스트 A의 초기 순서 번호
            - 1로 설정된 SYN 비트
    2. B to A
        - SYN + ACK 세그먼트
        - 주요 정보
            - 호스트 B의 초기 순서 번호
            - 호스트 A가 전송한 세그먼트에 대한 확인 응답 번호
            - 1로 설정된 SYN 비트
            - 1로 설정된 ACK 비트
    3. A to B
        - ACK 세그먼트
        - 주요 정보
            - 호스트 A의 다음 순서 번호
            - 호스트 B가 전송한 세그먼트에 대한 확인 응답 번호
            - 1로 설정된 ACK 비트

#### 연결 종료

- 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받으며 이루어짐
- 과정
    1. A to B
        - FIN 세그먼트
        - 주요 정보
            - 1로 설정된 FIN 비트
    2. B to A
        - ACK 세그먼트
        - 주요 정보
            - 호스트 A가 전송한 세그먼트에 대한 확인 응답 번호
            - 1로 설정된 ACK 비트
    3. B to A
        - FIN 세그먼트
        - 주요 정보
            - 1로 설정된 FIN 비트
    4. A to B
        - ACK 세그먼트
            - 호스트 B가 전송한 세그먼트에 대한 확인 응답 번호
            - 1로 설정된 ACK 비트

### TCP 상태

- 상태(state)
    - 현재 어떤 통신 과정에 있는지 나타내는 정보
    - TCP는 상태를 유지하고 활용한다는 점에서 stateful 프로토콜이라고도 불림
- 상태 분류
    - 연결이 수립되지 않은 상태
    - 연결 수립 상태
    - 연결 종료 상태

#### 연결이 수립되지 않은 상태

- CLOSED
    - 아무런 연결이 없는 상태
- LISTEN
    - 연결 대기 상태

#### 연결 수립 상태

- SYN-SENT
    - 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태
    - 연결 요청을 보낸 뒤 대기하는 상태
- SYN-RECEIVED
    - 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
- ESTABLISHED
    - 연결이 확립되었음을 나타내는 상태
    - 데이터를 송수신할 수 있는 상태
    - 쓰레 웨이 핸드셰이크 과정에서 두 호스트가 마지막 ACK 세그먼트를 주고받으면 ESTABLISHED 상태가 됨

#### 연결 종료 상태

- FIN-WAIT-1
    - 연결 종료의 첫 단계
    - FIN 세그먼트로서 연결 종료 요청을 보낸 액티브 클로즈 호스트는 FIN-WAIT-1 상태가 됨
- CLOSE-WAIT
    - 종료 요청인 FIN 세그먼트를 받은 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태
- FIN-WAIT-2
    - FIN-WAIT-1 상태에서 ACK 세그먼트를 받은 뒤의 상태
    - 상대 호스트의 FIN 세그먼트를 기다리는 상태
- LAST-ACK
    - CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 이에 대한 ACK 세그먼트를 기다리는 상태
- TIME-WAIT
    - 액티브 클로즈 호스트가 FIN 세그먼트를 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤의 상태
    - 패시브 클로즈 호스트는 마지막 ACK 세그먼트를 수신하면 CLOSED 상태로 전이
    - TIME-WAIT 상태에 접어든 액티브 클로즈 호스트는 일정 시간을 기다린 뒤 CLOSED 상태로 전이
- CLOSING
    - 동시에 연결을 종료하려 할 때 전이되는 상태
    - 양쪽 모두가 연결 종료를 요청하고 서로의 종료 응답을 기다리는 경우
    - ACK 세그먼트를 수신하면 각자 TIME-WAIT 상태로 접어든 뒤 종료

### UDP 데이터그램 구조

- UDP는 TCP와 달리 비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜임
- TCP처럼 상태를 유지하지 않고, 연결 수립 및 해제, 재전송을 통한 오류 제어, 혼잡 제어, 흐름 제어 등을 수행하지 않음
- 따라서 UDP는 stateless protocol이라고도 불림
- UDP 데이터그램 구조
    - 송신지 포트와 수신지 포트
    - 길이
        - 헤더를 포함한 UDP 데이터그램의 바이트가 담김
    - 체크섬
        - 데이터그램 전송 과정에서 오류가 발생했는지 검사하기 위한 필드
        - 수신지는 체크섬 값을 토대로 데이터그램의 정보가 훼손되었는지를 판단, 문제가 있다고 판단한 데이터그램 폐기
        - 수신지까지 잘 도착했는지를 나타내는 신뢰성/비신뢰성과는 관련이 없음
- UDP는 TCP에 비해 적은 오버헤드로 패킷을 빠르게 처리할 수 있어 실시간 스트리밍 서비스, 인터넷 전화처럼 실시간성이 강조되는 상황에서 TCP보다 더 많이 쓰임

## 4.3 TCP의 오류, 흐름, 혼잡 제어

- TCP의 신뢰성은 오류 제어, 흐름 제어, 혼잡 제어를 통해 보장됨
- TCP는 재전송을 기반으로 다양한 오류를 제어하고, 흐름 제어를 통해 처리할 수 있을 만큼의 데이터만을 주고받으며, 혼잡 제어를 통해 네트워크가 혼잡한 정도에 따라 전송량을 조절

### 오류 제어: 재전송 기법

#### 오류 검출과 재전송

- 체크섬은 세그먼트의 훼손 여부만 표기하므로, 체크섬을 이용한다고 해도 송신 호스트가 세그먼트 전송 과정에 문제가 있다는 것을 인지할 수 없음
- TCP의 신뢰를 보장하기 위해서는:
    - 송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지할 수 있어야 함
        - 중복된 ACK 세그먼트를 수신했을 때
        - 타임아웃이 발생했을 때
    - 오류를 감지하게 되면(세그먼트가 잘못 전송되었음을 알게 되면) 해당 세그먼트를 재전송할 수 있어야 함

#### ARQ(Automatic repeat Request, 자동 재전송 요구): 재전송 기법

- 수신 호스트의 답변(ACK)과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식

#### Stop-and-Wait ARQ

- 제대로 전달했음을 확인하기 전까지는 새로운 메시지를 보내지 않는 방식
- 메시지를 송신하고, 확인 응답을 받고, 다시 메시지를 송신하고, 이에 대한 확인 응답을 받는 것을 반복
- 단순하지만 높은 신뢰성을 보장
- 네트워크의 이용 효율이 낮아질 수 있음

#### Go-Back-N ARQ

- 파이프라이닝(pipelining) 방식을 활용하여 여러 세그먼트를 전송하고, 도중에 잘못 전송된 세그먼트가 발생할 경우 해당 세그먼트부터 전부 다시 전송하는 방식
- 송신 호스트의 특정 순서 세그먼트가 전송 과정에서 유실되었다면, 수신 호스트는 그 외 모든 세그먼트를 올바르게 수신했다 해도 이를 폐기
- 송신 호스트는 해당 순서 세그먼트에 대한 ACK 세그먼트를 받지 못하였으므로 타임아웃이 발생하고, 이를 통해 송신 호스트는 잘못된 송신이 있음을 인지
- 따라서 ACK 세그먼트를 수신받지 못한 해당 순서 세그먼트부터 다시 전송

#### Selective Repeat ARQ

- 수신 호스트 측에서 제대로 전송받은 각각의 패킷들에 대해 ACK 세그먼트를 보내는 개별 확인 응답(selective acknowledgement) 방식
- 송신 호스트는 올바르게 수신받지 못한 ACK 세그먼트가 있는지 검사하고, 응답받지 못한 세그먼트가 존재한다면 해당 세그먼트 재전송

### 흐름 제어(flow control): 슬라이딩 윈도우

- 호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계가 있으므로, 파이프라이닝 기반의 ARQ가 정상적으로 동작하려면 흐름 제어를 고려하여야 함
- 수신 버퍼
    - 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간
- 버퍼 오버플로우(buffer overflow)
    - 수신 버퍼의 크기보다 많은 데이터가 전송되어 일부 세그먼트가 처리되지 않는 상황
- 윈도우
    - 송신 호스트가 파이프라이닝할 수 있는 최대량
    - 송신 호스트는 윈도우의 크기만큼 확인 응답을 받지 않고 한 번에 전송할 수 있음
    
### 혼잡 제어

- 혼잡 제어를 수행하는 송신 호스트는 네트워크 혼잡도를 판단하고 혼잡한 정도에 맞춰 전송량을 조절하면서 전송
- 혼잡 윈도우(congestion window)
    - 혼잡 없이 전송할 수 있을 것 같은 데이터양
- 혼잡 윈도우가 크면 한 번에 전송할 수 있는 세그먼트 수가 많음을 의미하고, 혼잡 윈도우가 작다면 네트워크가 혼잡한 상황이기에 한 번에 전송할 수 있는 세그먼트 수가 적음을 의미
- AIMD(Additive Increase/Multiplicative Decrease) 알고리즘
    - 혼잡이 감지되지 않는다면 혼잡 윈도우를 선형적으로 증가시키고, 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨림
    - 혼잡 윈도우는 톱니 모양으로 변화함
- 느린 시작 알고리즘(slow start algorithm)
    - 혼잡 윈도우를 1부터 시작해 문제업싱 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식
    - 혼잡 윈도우는 2배씩 지수적으로 증가하므로 초기 전송 속도를 빠르게 확보할 수 있음
    - 상황별 대처
        - 타임아웃 발생
            - 혼잡 윈도우 값을 1로 초기화
            - 느린 시작 임계치를 혼잡이 감지되었을 시점의 혼잡 윈도우 값의 절반으로 초기화
            - 느린 시작 수행
        - 혼잡 윈도우 값이 느린 시작 임계치(slow start threshold)에 도달
            - 느린 시작 종료
            - 혼잡 윈도우를 절반으로 초기화한 뒤 혼잡 회피 수행
        - 세 번의 중복 ACK 발생
            - (빠른 재전송 후) 빠른 회복 수행
- 혼잡 회피 알고리즘(congestion avoidance algorithm)
    - RTT(Round Trip Time)마다 혼잡 윈도우를 1MSS(Maximum Segment Size)만큼 증가 
    - 혼잡 윈도우 크기는 선형적으로 증가함
    - 상황별 대처
        - 타임아웃 발생
            - 혼잡 윈도우 값을 1로 초기화
            - 느린 시작 임계치를 혼잡이 감지되었을 시점의 혼잡 윈도우 값의 절반으로 초기화
            - 느린 시작 수행
        - 세 번의 중복 ACK 발생
            - 혼잡 윈도우 값과 느린 시작 임계치를 절반으로 떨어뜨린 뒤 빠른 회복 알고리즘 수행
- 빠른 회복 알고리즘(fast recovery algorithm)
    - 세 번의 중복 ACK 세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행하여 빠르게 전송률을 회복하기 위한 알고리즘
    - 빠른 회복 도중이라도 타임아웃이 발생하면 혼잡 윈도우 크기는 1로, 느린 시작 임계치는 혼잡이 감지된 시점의 절반으로 떨어뜨린 후 다시 느린 시작 수행
